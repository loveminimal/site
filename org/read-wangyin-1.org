#+SETUPFILE: ../theme-rose.setup
#+DATE: <2021-02-03 Wed 12:07>
#+TITLE: 当然我在扯淡（一）

** 前言

王垠，这个人比较另类…… 好在我并在乎他在不在乎……

*PS. 正文部分是引用，嵌入部分是感想。具体正文请参考 https://www.yinwang.org/

** 什么是“对用户友好”

爱因斯坦说：“Any intelligent fool can make things bigger and more complex, and more violent. It takes a touch of genius - and a lot of courage - to move in the opposite direction.” 我现在深深体会到这句话的道理。想要简化一个东西让它更加“好用”，你确实需要很大的勇气，而且你必须确认单忽略这个东西的一些细节。

#+BEGIN_EXPORT html
<essay>
简化，法道。愈加认识事物的本质，才能谈简化、论主次，不然简化的途中就容易走了歧路。
</essay>
#+END_EXPORT

在机器的各个模块间，抽象表现为函数或者方法的类型（type），程序的模块（module）定义，操作系统的系统调用（system call），等等。但是它们的本质是一样的：他们告诉使用者“你能用我来干什么”。

#+BEGIN_EXPORT html
<essay>
科学抽象，合理封装。
</essay>
#+END_EXPORT

所以我们看到，“对用户不友好”的背后，其实是程序设计的不合理使得它们缺少抽象，而不是用户的问题。

#+BEGIN_EXPORT html
<essay>
请把用户当成一个“傻子”。如何对用户更加友好呢？统一、抽象、组合、解耦。
</essay>
#+END_EXPORT

** GTF - Great Teacher Friedman

程序语言的研究者们往往追逐一些“新概念”，却未能想到很多这些新概念早在几十年前就被 Friedman 想到了。

知识的尝试是无止境的。

Friedman 研究一个东西的时候总是全身心的投入，执着的热爱。

这是因为在 Cornell 学到这些东西的时候只是用来就会作业，而在 Friedman 的课上，我利用它们来完成有实际意义的目标，所以才真正的体会到这引起概念的内涵和价值。

#+BEGIN_EXPORT html
<essay>
实践是检验真理的唯一标准。在实践中认识规律，把握规律。学海无涯，此生有涯，当有的放矢，体验其中的美妙之处。动动手，不费事的。
</essay>
#+END_EXPORT

这是我第一次感觉到程序语言的理论对于现实世界的巨大威力，也让我理解到， *机器并不是计算的本质* 。机器可以用任何可行的技术实现，比如集成电路，激光，分子，DNA…… 但是无论用什么作为机器的材料，我们所要表达的语义，也就是计算的本质，却是不变的。

当然，重新发明东西并不会给我带来论文发表，但是它却给我带来了更重要的东西，这就是独立思考的能力。一旦一个东西被你“想”出来，而不是从别人那里“学”过来，那么你就知道这个想法是如何产生的。这比起直接学会这个想法要有用很多，因为你知道这里面所有的细节和犯过的错误。而最重要的，其实是由此得到的直觉。如果直接去看别人的书或者论文，你就很难得到这种直觉，因为一般人写论文会把直觉埋藏在一堆符号公式之下，让你看不到背后的真实想法。如果得到了直觉，下一次遇到类似的问题，你就有可能很快的利用已有的直觉来解决新的问题。

#+BEGIN_EXPORT html
<essay>
重新发明，Hmm... 重在理解，为什么要学，其发展历史、前景。其实，道理很简单，只有下到水里面，你才能真正知道自己会不会游泳。
</essay>
#+END_EXPORT

** 什么是语义学

一个程序的“语义”通常是由另一个程序决定的，这另一个程序叫做“解释器”（interpreter）。程序只是一个数据结构，通常表示为语法树（abstract syntax tree, AST）或者指令序列。这个数据结构本身其实没有意义，是解释器让它产生了意义。对同一个程序，可以有不同的解释。

解释器接受一个“程序”（program），输出一个“值”（value）。这个所谓的“值”可以具有非常广泛的含义，它可能是一个整数，一个字符串，也有可能是更加奇妙的东西。

所以“语义学”，基本上就是研究各种解释器。解释器的原理其实很简单，但是结构非常精巧微妙，如果你从复杂的语言入手，恐怕永远也学不会。最好的起步方式是写一个基本的 =lambda calculus= 的解释器。它只有三种无不，却可以表达所有程序语言的复杂结构。

专门讲语义的书很少，现在推荐一本我觉得深入浅出的：《Programming Languages and Lambda Calculi》。这本书好在什么地方呢？它是从非常简单的布尔表达式（而不是 =lambda calculus= ）开始讲解什么是递归的定义，什么是解释，什么是 =Church-Rosser= ，什么是上下文（evaluation context）。在让你理解了这种简单语言的语义，有了足够的信心之后，才告诉你更多的东西。比如 =lambda calculus= 和 CEK，SECD 等抽象机（abstract machine）。理解了这些概念之后，你就会发现所有的程序语言都可以比较容易理解了。

#+BEGIN_EXPORT html
<essay>
本质是脉络清晰的，是我们搞复杂了……
</essay>
#+END_EXPORT

** TODO 怎样写一个解释器

*PS. 具体的实现细节，请参考原文 https://www.yinwang.org/blog-cn/2012/08/01/interpreter ，该章节留待精读。

写一个解释器，通常是设计和实现语言的第一步。

实现语言容易犯的一个错误，就是一开关就试图去实现很复杂的语言（比如 JavaScript 或者 Python）。这样你很快就会因为这些语言的复杂性，以及各种历史遗留的设计问题而受到挫折，最后不了了之。学习实现语言，最好是从最简单，最干净的语言开始，迅速写出一个可用的解释器。之后再逐步往里面添加特性，同时保持正确。这样你才能有条不紊地构造出复杂的解释器。

现在我来谈一下，解释器到底是什么。说白了，解释器跟计算器差不多。解释器是一个函数，你输入一个“表达式”，它就输出一个“值”。

表达式是一种“表象”或者“符号”，而值却更加接近“本质”或者“意义”。我们“解释”了符号，得到它的意义，这也许就是为什么它叫做“解释器”。

需要注意的是，表达式是一个数据结构，而不是一个字符串。

从计算理论的角度讲，每个程序都是一台机器的“描述”，而解释器就是在“模拟”这台机器的运转，也就是在进行“计算”。所以，从某种意义上讲， *解释器就是计算的本质* 。当然，不同的解释器就会带来不同的计算。

CPU 也是一个解释器，它专门解释执行机器语言。如果你深刻理解了解释器，就可以从本质上看出各种 CPU 的设计为什么是那个样子，它们有什么优缺点，而不只是被动的作为它们的使用者。

#+BEGIN_EXPORT html
<essay>
所谓抽象，就是你可以随意跨越硬件和软件的界限。毕竟，从本质上来说，硬件和软件都是物质，不过都是道的载体。

<p>抽象语法树、树遍历算法、模式匹配。</p>

</essay>
#+END_EXPORT

** TeXmacs：一个真正“所见即所得”的排版系统

#+BEGIN_EXPORT html
<essay>
有时间学习学习……
</essay>
#+END_EXPORT

** Braid - 一个发人深思的游戏

我曾经是一个游戏迷，可是进入了计算机专业的学习之后，我就开始失去对游戏的兴趣，基本上每玩一个都让我失望一次，不管别人把它吹的多么“经典”。不知道为什么，别人玩得津津有味的游戏，我玩一会儿就把它里面的“公式”都看透了。我清楚地知道这游戏的设计者是怎么在“耍我”，在如何想方设法浪费我的时间。

同样的，别人看得津津有味的小说和电影，我经常一看开头就能猜到它要怎么发展，知道这编剧是怎么在胡编滥造，索然无味。所以我基本上不去影院看最新的电影，宁愿在网上看一些几十年前的老电影。我貌似只喜欢那些能让我“猜不透”的东西。

#+BEGIN_EXPORT html
<essay>
Hmm...
</essay>
#+END_EXPORT

** 解密“设计模式”

有些人问我，你说学习操作系统的最好办法是学习程序设计。那我们是不是应该学习一些“设计模式”（design patterns）。这是一个我很早就有定论，而且经过实践检验的问题。

总的来说，如果光从字面上讲，程序里确实是有一些“模式”可以发掘的。因为你总是可以借鉴以前的经验，用来构造新的程序。你可以把这种经验叫做“模式”。可是自从《设计模式》（GoF）这本书在 1994 年发表以来，“设计模式”这个词有了新的，扭曲的含义。它变成了一种教条，带来了公司里程序的严重复杂化以及效率低下。

#+BEGIN_EXPORT html
<essay>
需要注意的是，要具体问题，具体分析。杀鸡用牛刀，不是大材小用，而是根本就不好用。要从长期和短期以及问题体量来认真分析才好。
</essay>
#+END_EXPORT

照搬模式东拼西凑，而不能抓住事物的本质，没有“灵感”，其实是设计不出好东西的。

我很快的发现，其实这本书的作者只是给早已经存在的编程方法起了一些新的名字而已。当时我就拿起一张纸，把所有的20来个设计模式跟我常用的编程概念做了一个映射。这个映射居然是“多对一”的。也就是说，多个 GoF 设计模式，居然只对应同一个我每天都用的概念。有些概念是如此的不值一提，以至于我根本不需要一个名字来描述它，更不要说多个名字。

#+BEGIN_EXPORT html
<essay>
Hmm... 是本好书，值得一看。本来就是已有的概念，讲述出来，各自印证嘛。
</essay>
#+END_EXPORT

其中极少数值得一提的“模式”，也许是 =visitor= 和 =interpreter= 。很可惜的是，只有很少人如何使用它们。所谓的 =visitor= ，本质上就是函数式语言里的含有“模式匹配”（pattern matching）的递归函数。在函数式语言里，这是多么轻松的事情。可是因为 Java 没有模式匹配，所以很多需要类似功能的人就得使用 =visitor pattern= 。为了所谓的“通用性”，他们往往把 =visitor pattern= 搞出多层继承关系，让你转几道弯也搞不清楚到底哪个 =visitor= 才是干实事的。

#+BEGIN_EXPORT html
<essay>
分清本末。
</essay>
#+END_EXPORT

这不是我的一家之言中，Peter Norving 在 1998 年就做了一个演讲，指出在“动态语言”里面，GoF 的 20 几个模式，其中绝大部分都“透明”了。也就是说，你根本感觉不到它们的存在。在这里 Norving 的观点是正确的，不过需要小心一个概念错误。Norving 对“静态语言”的概念是有局限性的。有的静态语言其实也能传递函数作为参数，而且不像 Java 那样什么都得放进 class 里。这样的静态语言，其实也可以避免大部分的 GoF 设计模式。而“动态语言”这个概念，在程序语言的理论里面，其实是没有明确的定义的。“动态语言”其实也能进行某些“静态类型检查”。

#+BEGIN_EXPORT html
<essay>
所有的概念都是为了描述那个唯一。
</essay>
#+END_EXPORT

可见一本坏书，毁掉的不只是一代程序员。鉴于如此，特发此文。各位新手，希望你们敲响警钟，不要再走上这条老路，写出代码来让大家痛苦。

#+BEGIN_EXPORT html
<essay>
该观点，不予置评。难道因为不能做到最好，还不做好事了……
</essay>
#+END_EXPORT

** 谈 Linux，Windows 和 Mac

天知道他们在哪里找到那么老的文章，真是好事不出门…… 我觉得我有责任消除我以前的文章对人的误导，洗清我这个“Linux 狂热分子”的恶名。

#+BEGIN_EXPORT html
<essay>
Hmm... 谁还没年轻过……
</essay>
#+END_EXPORT

简言之，我想对那些觉得 Linux 永远也学不会的“菜鸟”们说：

1.Linux 和 Unix 里面包含了一些非常糟糕的设计。不要被 Unix 的教条主义者吓倒。学不会有些东西很多时候不是你的错，而是 Linux 的错，是 “Unix 思想”的错。不要浪费时间去学习太多工具的用法，钻研稀奇古怪的命令行。寻些貌似难的，复杂的东西，特别要小心分析。

#+BEGIN_EXPORT html
<essay>
教条主义不可取，一点不取也不可取。比如一个构建工具，常规的配置用法还是要烂熟于心的，但是你总不可能都记住。比如，纷繁复杂的各种插件，及其适用场景。但是有点是相通的，就是插件的本质，多数不过是一个函数罢了。尝试着去实现几个插件，就会明了其中的道。
</essay>
#+END_EXPORT

2.Windows 避免了 Unix, Linux 和 Mac OSX 的很多问题。微软是值得尊敬的公司，是真正在乎程序开发工具的公司。

Visual Studio 是非常好的工具，会带来编程效率的大同谋提升，请不要歧视 IDE。要正视 Emacs，VIM 等文本编辑器的局限性。

#+BEGIN_EXPORT html
<essay>
Visual Studio Code 堪称后起之秀…… 让每种工具做它最善长的东东，才是王道。
</essay>
#+END_EXPORT

*3.学习操作系统最好的办法是学会（真正的）程序设计思想* ，而不是去“学习”各种古怪的工具。所有操作系统，数据库，Internet，以至于 WEB 的设计思想（和缺陷），几乎都能用到程序语言的思想简单的解释。

我曾经强烈的推崇 FVWM，TeX 等工具，可是现在擦亮眼睛看来，它们给用户的界面，其实也是非常糟糕的设计，跟 Unix 一脉相承。

#+BEGIN_EXPORT html
<essay>
实事求是，打脸自己也在所不惜……
</essay>
#+END_EXPORT

一个好的工具，应该只有少数几条需要记忆的规则，就像象棋一样。

有些人鄙视图形界面，鄙视 IDE，鄙视含有垃圾回收的语言（比如 Java），鄙视一切“容易”的东西。他们却不知道，把自己沉浸在别人设计的繁复的规则中，是始终无法成为大师的。

所以，容易的东西不一定是坏的，而困难的东西也不一定是好的。学习计算机（或者任何其它工具），应该“只选对的，不选难的”。记忆一堆的命令，乌七八糟的工具用法，最后脑子里面什么也不会留下。学习“原理性”的东西，才是永远还会过时的。

由于受到“Unix 哲学”的误导，Unix 的程序间交换数据一起以来都是用字符串，而且格式得不到统一，以至于很多程序连拷贝粘贴都没法正确进行。

Windows 的“配置”，全都记录在一个中央数据库（注册表）里面，这样程序的配置得到大大的简化。相反，Unix 的配置，全都记录在各种稀奇古怪的配置文件里面，分布在系统的各个地方。你搞不清楚哪个配置文件记录了你想要的信息。每个配置文件连语法都不一样！这就是为什么用 Unix 的公司总是需要一个“系统管理员”，因为软件工程师们才懒得记这些麻烦的东西。

#+BEGIN_EXPORT html
<essay>
有说好的，有说坏的，Hmm…… 再议。
</essay>
#+END_EXPORT

公司还不都一样，都是以利益为本的。我们程序员就不要被他们利用，作为利益斗争的炮灰啦。见到什么好就用什么，就学什么。自己学到的东西，又不属于那些垄断企业。我们都有自由的头脑。

#+BEGIN_EXPORT html
<essay>
知识是自己的。
</essay>
#+END_EXPORT

我只是想告诉新人们，去除头脑里的宗教，偏激，仇恨和鄙视。每次仇恨一个东西，你就失去了向它学习的机会。

#+BEGIN_EXPORT html
<essay>
But…… 王垠现在也是身在樊笼而不自知，看来说出道理的人也不一定是按道理办事的，自己也是一个样……
</essay>
#+END_EXPORT

** Oberon 操作系统：被忽略的珍宝

Oberon 比起 Unix，有很大的不同，在于它的数据都是结构化的。进程间不通过字符串交换数据，而是直接使用数据结构。

操作系统的设计，真是天外有天。

#+BEGIN_EXPORT html
<essay>
我在想，最终是不是都绕不开字符串？待求证！
</essay>
#+END_EXPORT

** 谈语法

使用和研究过这么多程序之后，我觉得几乎不包含多余功能的语言，只有一个：Scheme 。所以，我觉得它是学习程序设计最好的入手点和进阶工具。当然 Scheme 也有少数的问题，但这些都瑕不掩瑜。

#+BEGIN_EXPORT html
<essay>
和 Elisp 有点像，有时间多了解一点。
</essay>
#+END_EXPORT

其它的 Lisp “方言”也有跟 Shecme 类似的语法（都是基于“S 表达式”），本文后续，“Scheme” 和 “Lisp” 这两个词基本上含义相同。

我觉得 Scheme（Lisp）的基于“S 表达式”（S-expression）的语法，是世界上最完美的设计。

为什么我喜欢这样一个“全是括号，前缀表达式”的语言呢？这是出于对语言结构本质的考虑。其实，我觉得语法是完全不应该存在的东西。即使存在，也应该非常的简单。因为 *语法其实只是对语言的本质结构 - 抽象语法树（AST）的一种编码* 。一个良好的编码，应该极度简单，不引起歧义，而且应该容易解码。在程序语言里，这个“解码”的过程叫做“语法分析”（parse）。

为会么需要语法呢？因为受到现有工具（操作系统，文本编辑器）的限制，到目前为止，几乎所有语言的程序都是 *用字符串的形式存放在文件里的* 。为了让字符串能够表示“树”这种结构，人们才给程序设计了“语法”这种东西。但是人们喜欢耍小聪明，在有了基本的语法之后，他们开始在这上面大做文章，使得简单的问题变得复杂。

#+BEGIN_EXPORT html
<essay>
最终是为了“树”结构！
</essay>
#+END_EXPORT

Lisp（Shceme 的前身）是世界上第二老的程序语言，最老的是 Fortran 。Fortran 的程序，最早的时候都是用打孔机打在卡片上的，所以它其实是几乎没有语法可言的。

显然，这样写程序很痛苦。但是它却比现代很多有一个优点：它没有歧义，没有复杂的 parse 过程。

在 Lisp 诞生的时候，它的设计者们一下子没能想出一种好的语法，所以他们决定干脆先用括号把这语法树的结构全都括起来，一个不漏，等想到更始的语法再换。

#+BEGIN_EXPORT html
<essay>
这样也可以啊……
</essay>
#+END_EXPORT

自己想一下，如果要表达一颗“树”，最简单的编码方式是什么？就是用括号把它的每个节点的“数据”和“子节点”都括起来放在一起。Lisp 的设计者们就是这样想的。他们把这种完全用括号括进来的表达式，叫做 _“S 表达式”_ （S 代表 symbolic）。这貌似是很“粗糙”的设计，甚至根本谈不上“设计”。奇怪的是，在用过一段时间之后，他们发现自己已经爱上了这个东西，再也不想设计更加复杂的语法。于是 S 表达式就沿用至今。

#+BEGIN_EXPORT html
<essay>
Elisp 更接近于树，原来如此。

<p>爱情，就是这么的在不知不觉间产生了……</p>
</essay>
#+END_EXPORT

在使用过 Scheme，Haskell，ML，和常见的 Java，C，C++ ，Python，Perl…… 之后，我也惊讶的发现，Scheme 的语法，不但是最简单，而且是最好看的一个。

首先，把所有的结构都用特括起来，轻松地避免了别的语言里面可能发生的“歧义”。程序员不再需要记忆任何“运算符优先级”。

其次，把“操作符”全都放在表达式的最前面，使得基本算术操作和函数调用，在语法上发生完美的统一，而且使得程序员可以使用几乎任何符号作为函数名。

#+BEGIN_EXPORT html
<essay>
函数调用在这里看进来像 `(f arg1 arg2 ...)`，而不是类 C 语言中的 `f(arg1, arg2, ...)`，
是的，算术操作和函数在这里也得到了形式上的统一。想想也是合理的，算术操作本身不就是一种函数嘛……
</essay>
#+END_EXPORT

关于“前缀表达式”与“中缀表达式”，我有一个很独到的见解：我觉得“中缀表达式”其实是一种过时的，来源于传统数学的历史遗留产物。几百年来，人们都在用 =x+y= 这样的符号来表示加法。之所以这样写，是因为在没有计算机以前，数学公式都得写在纸上，写 =x+y= 显然比 =(+ x y)= 方便简洁。但是，中缀表达式却是容易出现歧义的。如果你有多个操作符，比如 =1+2*3= ，那么它表示的是 =(+ 1 (* 2 3))= 呢，还是 =(* (+ 1 2) 3)= 呢？看见没有，S表达式已经在这里显示出它没有歧义的优点，你并不需要知道 =+= 和 =*= 的优先级。

对于四则运算，这些优先级还算简单。可以一旦有了更多的操作，就容易出现混淆。这就是为什么数学（以及逻辑学）的书籍难以看懂。实际上，那些看似复杂的公式，符号，不过是在表示一些程序里的“数据结构”，“对象”以及“函数”。大部分读数学书的时间，其实是浪费在琢磨这些公式：它们到底要表达的什么样一个“数据结构”或者“操作”！这个“琢磨”的过程，其实就是程序语言里所谓的“语法分析”（parse）。

#+BEGIN_EXPORT html
<essay>
殊途同归！
</essay>
#+END_EXPORT

这种问题在微积分里面就更加明显。微积分难学，很大部分原因，就是因为微积分的那些传统的运算符，其实不是很好的设计。

其实 Lisp 已经可以轻松地表示这种公式，比如对 =x^2= 进行微分，可以表示成：

#+BEGIN_EXAMPLE
(D '(^ x 2) 'x)
#+END_EXAMPLE

看到了吗？微分不过是一个用于处理符号的函数 =D= ，输入一个表达式和另一个符号，输出一个新的表达式。

同样的公式，传统的数学符号是这个样子：

#+BEGIN_EXPORT html
<img
src="http://www.yinwang.org/images/deriv-math.png"
width="80"
height=""
style=""
title=""
/>
#+END_EXPORT

这是什么玩意啊？ =d= 除以 =dx= ，然后乘以 =x= 的平方？

#+BEGIN_EXPORT html
<essay>
确实是这么回事，传统数学中微积分的 “2D语法” 让人很费解。
</essay>
#+END_EXPORT

其实我一起在想，如果把数学看成是一种程序语言，它也许就是世界上语法最糟糕的语言。数学里的“变量”，几乎总是没有明确定义的作用域（scope）。也就说他们只有“全局变量”。

可惜的是，很多程序语言的设计者没能摆脱数学的思想束缚，对数学和逻辑有盲目崇拜的倾向。所以他们继续在新的语言里使用中缀表达式法。

另外，由于 Lisp 的表达能力和灵活性比其他语言要大很多，所以类似 C 或者 Pascal 那样的语法其实不能满足 Lisp 的需要。在 Lisp 里，你可以写 =(+ 10 (if test 1 2))= 这样的代码，然而如果你使用 C 那样的无括号语法，就会发现没法很有效的嵌入里面的那个条件语句而不出现歧义。这就是为什么 C 必须使用 =test?1:2= 这样的语法来表示 Lisp 的 =if= 能表示的东西。然而即使如此，你仍然会经常补迫加上一对括号，结果让程序非常难看，最后的效果其实还不如用 Lisp 的语法。在 C 这样的语言里，由于结构上有很多限制，所以才觉得那样的语法还可以。可是一旦加入 Lisp 的那些表达式能力强的结构，就发现越来越难看。 JavaScript （node.js）就是对此最好的一个证据。

最后，从美学的角度上讲，S 表达式是很美观的设计。

#+BEGIN_EXPORT html
<essay>
确实很好用，应该好好地学习一门类 Lisp 的语言，比如 Emacs Lisp ，还可以顺便 hack 一下 Emacs 。

<p>简洁和省略，是因为没有歧义，表意唯一。</p>
</essay>
#+END_EXPORT

Lisp 的很多其它的设计，比如“垃圾回收”，后来被很多现代语言（比如 Java）所借鉴。可是人们遗漏了一个很重要的东西：Lisp 的语法，其实才是世界上最好的语法。
