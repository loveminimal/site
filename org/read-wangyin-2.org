#+SETUPFILE: ../theme-rose.setup
#+DATE: <2021-02-04 Thu 16:54>
#+TITLE: 当然我在扯淡（二）

** 程序语言的常见设计错误(1) - 片面追求短小

我经常以自己写“非常短小”的代码为豪。

我的程序的“短小”是建立在语义明确，概念清晰的基础上的。在此基础上，我力求去掉冗余的，绕弯子的，混淆的代码，让程序更加直接，更加高效的表达我心中设想的“模型”。这是一种在概念级别的优化，而程序的短小精悍只是它的一种“表象”。就像是整理一团电线，并不是把它们揉成一团然后塞进一个盒子里就好。这样的做法只会给你以后的工作带来更大的麻烦，而且还有安全隐患。

所以我的这种短小往往是语义和逻辑层面的，而不是在语法上死抠几行代码。我绝不会为了程序显得短小而让它变得难以理解或者容易出错。相反，很多其他人所追求的短小，却是盲目的而没有原则的。在很多时候这些小伎俩都只是在语法层面上，比如想办法把两行代码“搓”成一行。可以说，这种“片面追求短小”的错误倾向，造就了一批语言设计上的错误，以及一批“擅长于”使用这些错误的程序员。

现在我举几个简单的“片面追求短小”的语言设计。

*** 自增减操作

很多语言里都有 i++ 和 ++i 这两个“自增”操作和 i-- 和 --i 这两个“自减”操作（下文合称“自增减操作”。很多人喜欢在代码里使用自增减操作，因为这样可以“节省一行代码”。殊不知，节省掉的那区区几行代码比起由此带来的混淆和错误，其实是九牛之一毛。）

从理论上讲，自增减操作本身就是错误的设计。因为它们把对变量的“读”和“写”两种根本不同的操作，毫无原则的合并在一起。这种对读写操作的混淆不清，带来了非常难以发现的错误。相反，一种等价的，“笨”一点的写法， =i=1+1= ，不但容易理解，而且在逻辑上更加清晰。

有些人很在乎 =i++= 与 =++i= 的区别，去追究 =(i++) + (++i)= 这类表达式的含义，追究 =i++= 与 =++i= 谁的效率更高。这些其实都是徒劳的。比如， =i++= 与 =++i= 的效率差别，其实来自于早期 C 编译器的愚蠢。因为 =i++= 需要在增加这后返回 =i= 原来的值，所以它其实被编译为：

#+BEGIN_EXAMPLE
(tmp = i, i = i + 1, tmp)
#+END_EXAMPLE

但是在

#+BEGIN_EXAMPLE
for (int i = 0; i < max; i++)
#+END_EXAMPLE

这样的语句中，其实你并不需要在 =i++= 之后得到它自增前的值。

#+BEGIN_EXPORT html
<essay>
原来，是这个意思，原来是这样……
</essay>
#+END_EXPORT

所以有人说，在这里应该用 =++i= 而不是 =i++= ，否则你就会浪费一次对中间变量 =tmp= 的赋值。而其实呢，一个良好设计的编译器应该在两种情况下都生成相同的代码。这是因为在 =i++= 的情况，代码其实先被转化为：

#+BEGIN_EXAMPLE
for (int i = 0; i < max; (tmp = i, i = i + 1, tmp))
#+END_EXAMPLE

由于 =tmp= 这个临时变量从来没用过，所以它会被编译器的 “dead code elimination” 消去。所以编译器最后实际上得到了：

#+BEGIN_EXAMPLE
for (int i = 0; i < max; i = i + 1)
#+END_EXAMPLE

所以，“精通”这些细微的问题，并不能让你成为一个好和程序员。很多人所认为的高明的技巧，经常都是因为早期系统设计的缺陷所致。一旦这些系统被改进，这些技巧没什么用处了。

真正正确的做法其实是：完全不使用自增操作，因为它们本来就是错误的设计。

*** 赋值语句返回值

在几乎所有像 C，C++，Java 的语言里， *赋值语句都可以被作为值* 。之所以设计成这样，是因为你就可以写这样的代码：

#+BEGIN_EXAMPLE
if (y = 0) { ... }
#+END_EXAMPLE

而不是

#+BEGIN_EXAMPLE
y = 0;
if (y) { ... }
#+END_EXAMPLE

程序好像缩短了一行，然而，这种写法经常引起一种常见的错误，那就是为了写 ~if (y == 0) { ... }~ 而把 ~==~ 比较操作符少打了一个 ~=~ ，变成了 ~if (y = 0) { ... }~ 。很多人犯这个错误，是因为数学里的 ~=~ 就是比较两个值是否相等的意思。

正确的做法是什么呢？在一个类型完备的语言里面，像 ~y=0~ 这样的赋值语句，其实是不应该可以返回一个值的，所以它不允许你写：

#+BEGIN_EXAMPLE
x = y = 0
#+END_EXAMPLE

或者

#+BEGIN_EXAMPLE
if ( y = 0) { ... }
#+END_EXAMPLE

这样的代码。

~x = y = 0~ 的工作原理其实是这样：经过 parser 它其实变成了 ~x = (y = 0)~ （因为 ~=~ 操作符是“右结合”的）。 ~x = (y = 0)~ 这个表达式也就是说 =x= 被赋值为 =(y = 0)= 的值。注意，我说的是 =(y = 0)= 这整个表达式的值，而不是 =y= 的值。所以这里的 =(y = 0)= 既有副作用又是值，它返回 =y= 的“新值”。

正确的做法其实是： =y = 0= 不应该具有一个值。它的作用应该是“赋值”这种“动作”，而不应该具有任何“值”。即使牵强一点硬说它有值，它的值也应该是 =void= 。这样一来 ~x = y = 0~ 和 ~if (y = 0)~ 就会因为“类型不匹配”而被编译器拒绝接受，从而避免了可能出现的错误。

#+BEGIN_EXPORT html
<essay>
从源头解决问题的出现，而不只为了解决出现的问题。
</essay>
#+END_EXPORT
