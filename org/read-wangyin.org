#+SETUPFILE: ../theme-rose.setup
#+DATE: <2021-02-02 Tue 11:10>
#+TITLE: Read Wangyin

** [[http://www.yinwang.org/blog-cn/2012/05/18/user-friendliness][什么是“对用户友好”]]

#+BEGIN_QUOTE
"Any intelligent fool can make things bigger, more complex, and more violent. It takes a touch of genius - and a lot of courage - to move in the opposite direction."\\
–- Albert Einstein
#+END_QUOTE

简化一个东西，让它更“好用”，你需要认真了解它的本质和用途！

对于用户（包括你）来说，它应该被合理地抽象，隐藏内部的细节，只需要告诉用户“你能用它来干什么”。

如何使之对用户更加友好呢？统一、抽象、减冗、组合。

** [[http://www.yinwang.org/blog-cn/2012/07/04/dan-friedman][GTF - Great Teacher Friedman]]

程序语言的研究者们往往追逐一些“新概念”，Hmm...煞有其事。

知识的深度是无止境的。

只有利用所学内容来完成有实际意义的目标，你才能真正体会到其概念的内涵和价值。

重新“发明”，有利于独立思考。一旦一个东西被你“想”出来，而不是从别人那里“学”过来，那么你就知道这个想法是如何产生的。这比起直接学会这个想法要有用的多，因为你知道这里面所有的细节和犯过的负荆错误。而最重要的，其实是由此得到的直觉。

#+BEGIN_EXPORT html
<essay>
纸上得来终觉浅，绝知此事要躬行。
</essay>
#+END_EXPORT

** [[http://www.yinwang.org/blog-cn/2012/07/25/semantics][什么是语义学]]

一个程序的“语义”通常是由另一个程序决定的，这另一个程序叫做“解释器”（interpreter）。程序本身只是一个数据结构，通常表示为语法树（abstract syntax tree）或者指令序列。这个数据结构本身其实没有意义，是解释器让它产生了意义。

#+BEGIN_EXPORT html
<essay>
对同一个程序，不同的解释器可以有不同的解释。
</essay>
#+END_EXPORT

解释器接受一个“程序”（program），输出一个“值”（value）。这个所谓的“值”可以具有非常广泛的含义，它可能是一个整数、一个字符串，也有可能是更加奇妙的东西。

其实解释器不止存在于计算机中，它是一个很广泛的概念。

#+BEGIN_EXPORT html
<essay>
对于固定输入，总会进行唯一的解释，给出固定输出。
</essay>
#+END_EXPORT

所以“语义学”，基本上就是研究各种解释器。解释器的原理其实很很简单，但是结构非常微妙，如果你从复杂的语言入手，恐怕永远也学不会。最好的起步方式是写一个基本的 =lambda calculus= 的解释器，它只有三种元素，却可以表达所有程序语言的复杂结构。

** TODO [[http://www.yinwang.org/blog-cn/2012/08/01/interpreter][怎样写一个解释器]]

写一个解释器，通常是设计和实现程序语言的第一步。

实现语言容易犯一个错误，就是一开关就试图去实现很复杂的语言（比如 JavaScript 或者 Python）。这样你很快就会因为这些语言的复杂性，以及各种历史遗留的设计问题而受到挫折，最后不了了之。学习实现语言，最好是从最简单、最干净的语言开始，迅速写出一个可用的解释器。之后，再逐步往里面添加特性，同时保持正确，如此你才能有条不紊地构造出复杂的解释器。

*** 解释器是什么

说白了，解释器跟计算机差不多。 *解释器是一个函数* ，你输入一个“表达式”，它就输出一个“值”。比如，你输入表达式 ='(+ 1 2)= ，它就输出值，整数 =3= 。

表达式是一种“表象”或者“符号”，而值更加接近“本质”或者“意义”。我们“解释”了符号，得到它的意义，这也许就是为什么它叫做“解释器”。

需要注意的是，表达式是一个数据结构，而不是一个字符串。

我们用一种叫“S 表达式”（S-expression）的结构来存储表达式。比如，表达式 ='(+ 1 2)= 其实是一个链表（list），它里面的内容是三个符号（symbol）： =+, 1= 和 =2= ，而不是字符串 ="(+ 1 2)"= 。

从 S 表达式这样的“结构化数据”里提取信息，方便又可靠，而从字符串里提取则麻烦且容易出错。Scheme（Lisp）语言里面大量使用结构化数据，少用字符串，是 Lisp 系统比 Unix 系统先进的地方之一。

从计算机理论的角度讲，每个程序都是一台机器的“描述”，而解释器就是在“模拟”这台机器的运行，也就是在进行“计算”。所以，从某种意义上讲， *解释器就是计算的本质* 。

CPU 也是一个解释器，它专门解释执行机器语言。如果你深刻理解了解释器，就可以从本质上看出各种 CPU 的设计为什么是那个样子，它们有什么优缺点，而不只是被动的作为它们的使用者。

#+BEGIN_EXPORT html
<essay>
解释器是一个函数，是计算的本质。
</essay>
#+END_EXPORT

*** 抽象语法树

i.e. Abstract Syntax Tree（AST）

用 S 表达式所表示的代码，本质上是一种叫做“树”（tree）的数据结构 -- 抽象语法树（AST），以下简称语法树。

跟普通的树结构一样，语法树里的节点，要么是一个“叶节点”，要么是一颗“子树”。叶节点是不能再细分的“原子”，比如数字、字符串、操作符、变量名。而子树是可以再细分的“结构”，比如算术表达式、函数定义、函数调用等。

*** 树遍历算法

在基础的数据结构课程中，我们学过二叉树的遍历操作，也就是所谓的先序遍历、中序遍历和后序遍历。语法树和二叉树没有很大区别，所以你也可以在它上面进行遍历。

解释器的算法，就是在语法树上的一种遍历操作。

我们先来做一个遍历二叉树的练习，做好了之后，我们就可以把这段代码扩展成一个解释器。

这个练习是这样：写出一个函数 =tree-sum= ，它对二叉树进行“求和”，把所有节点里的数加在一起，返回它们的和。举个例子， =(tree-sum '((1 2) (3 4)))= ，执行后应该返回 =10= 。

*注意：这是一颗二叉树，所以不会含有长度超过 2 的子树，你不需要考虑像 =((1 2) (3 4 5))= 这类情况。

我们的代码是这个样子：

#+BEGIN_SRC scheme -n
#lang racket

(define tree-sum
  (lambda (exp)
    (match exp                         ; 对输入exp进行模式匹配
      [(? number? x) x]                ; exp是一个数x吗？如果是，那么返回这个数x
      [`(,e1 ,e2)                      ; exp是一个含有两棵子树的中间节点吗？
       (let ([v1 (tree-sum e1)]        ; 递归调用tree-sum自己，对左子树e1求值
             [v2 (tree-sum e2)])       ; 递归调用tree-sum自己，对右子树e2求值
         (+ v1 v2))])))                ; 返回左右子树结果v1和v2的和
#+END_SRC

更多内容，请直接参考 http://www.yinwang.org/blog-cn/2012/08/01/interpreter

** [[http://www.yinwang.org/blog-cn/2012/09/18/texmacs][TeXmacs：一个真正“所见即所得”的排版系统]]

……

** [[http://www.yinwang.org/blog-cn/2013/03/04/braid][Braid - 一个发人深思的游戏]]

游戏确实挺有意思的，可惜我是个菜鸟……

#+BEGIN_QUOTE
我曾经是一个游戏迷，可是进入了计算机专业的学习之后，我就开始失去对游戏的兴趣，基本上每玩一个都让我失望一次，不管别人把它吹的多么“经典”。不知道为什么，别人玩得津津有味的游戏，我玩一会儿就把它里面的“公式”都看透了。我清楚地知道这游戏的设计者是怎么在“耍我”，在如何想方设法浪费我的时间。

同样的，别人看得津津有味的小说和电影，我经常一看开头就能猜到它要怎么发展，知道这编剧是怎么在胡编滥造，索然无味。所以我基本上不去影院看最新的电影，宁愿在网上看一些几十年前的老电影。我貌似只喜欢那些能让我“猜不透”的东西。
#+END_QUOTE

糊涂是福啊，王垠……

** [[http://www.yinwang.org/blog-cn/2013/03/07/design-patterns][解密“设计模式”]]

