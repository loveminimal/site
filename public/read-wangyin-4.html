<!DOCTYPE html>
<html lang="zh">
<head>
<!-- 2021-02-07 Sun 17:00 -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>当然我在扯淡（四）</title>
<meta name="generator" content="Org mode">
<meta name="author" content="Jack Liu">
<link rel="shortcut icon" href="/images/rose-red.png" type="image/x-icon" />
<link rel="stylesheet" type="text/css" href="/dist/style.css" />
<script src="/dist/main.js" defer></script>
</head>
<body>
<div id="content">
<h1 class="title">当然我在扯淡（四）</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org2af3358">Yoda 表示法错在哪里</a></li>
<li><a href="#orgcb617e4">关于语言的思考</a></li>
<li><a href="#orgb997131">程序语言的常见设计错误(2) - 试图容纳世界</a></li>
<li><a href="#org149efc6">编辑器与 IDE</a></li>
<li><a href="#org497c9e8">程序语言不是工具</a></li>
<li><a href="#org3fae475">ydiff - 结构化的程序比较</a></li>
<li><a href="#org8bee885">原因与证明</a></li>
<li><a href="#org4fa9111">我离开了 Coverity</a></li>
<li><a href="#org052ae27">PyDiff - Python 结构化程序比较工具</a></li>
<li><a href="#orgf45dfe1">丘奇和图灵</a></li>
</ul>
</div>
</div>

<div id="outline-container-org2af3358" class="outline-2">
<h2 id="org2af3358">Yoda 表示法错在哪里</h2>
<div class="outline-text-2" id="text-org2af3358">
<p>
……
</p>
</div>
</div>

<div id="outline-container-orgcb617e4" class="outline-2">
<h2 id="orgcb617e4">关于语言的思考</h2>
<div class="outline-text-2" id="text-orgcb617e4">
<p>
我今天想说其实就是，没有任何一种语言值得你用毕生的精力去“精通”它。“精通”其实代表着“脑残”——你成为了一个高效的机器，而不是一个有自己头脑的人。你必须对每种语言都带有一定的怀疑态度，而不是完全的拥抱它。每个人都应该学习多种语言，这样才不至于让自己的思想受到单一语言的约束，而没法接受新的，更加先进的思想。这就像每个人都应该学会至少一门外语一样，否则你就深陷于自己民族的思维方式。有时候这种民族传统的思想会让你深陷无须有的痛苦却无法自拔。
</p>
</div>
</div>

<div id="outline-container-orgb997131" class="outline-2">
<h2 id="orgb997131">程序语言的常见设计错误(2) - 试图容纳世界</h2>
<div class="outline-text-2" id="text-orgb997131">
<p>
今天我要说的错误倾向叫做“试图容纳世界”。这个错误导致了 Python，Ruby 和 JavaScript 等“动态语言”里面的一系列问题。
</p>

<p>
……
</p>

<p>
语言的设计者们都应该明白，程序语言不是用来“构造世界”的，而只是对它进行简单的模拟。试图容纳世界的倾向，没带来很多好处，没有节省程序员很多精力，却使得代码完全没有规则可言。这就像生活在一个没有规则，没有制度，没有法律的世界，经常发生无法预料的事情，到处跑着没有头，三只手，六只眼的怪人。这是无穷无尽的烦恼和时间精力的浪费。
</p>

<essay>
做一个“建筑师”，而不是上帝……
</essay>
</div>
</div>

<div id="outline-container-org149efc6" class="outline-2">
<h2 id="org149efc6">编辑器与 IDE</h2>
<div class="outline-text-2" id="text-org149efc6">
<p>
很多人都喜欢争论哪个编辑器是最好的，其中最大的争论莫过于 Emacs 与 vi 之争。
</p>

<p>
那么我对此的答案是什么呢？在目前的情况下，我对程序编辑的临时答案是：IDE。
</p>

<p>
写程序的时候，我通常根据语言来选择最能“理解”那种语言的“IDE”（比如 Visual Studio, Eclipse, IntelliJ IDEA 等），而不是一种通用的“文本编辑器”（比如 Emacs, vi, jEdit, …）。这是因为“文本编辑器”这种东西一般都不真正的理解程序语言。很多 Emacs 和 vi 的用户以为用 etags 和 ctags 这样的工具就能让他们“跳转到定义”，然而这些 tags 工具其实只是对程序的“文本”做一些愚蠢的 <b>正则表达式匹配</b> 。它们根本没有对程序进行 parse，所以其实只是在进行一些“瞎猜”。简单的函数定义它们也许能猜对位置，但是对于有重名的定义，或者局部变量的时候，它们就力不从心了。
</p>

<p>
想要设计一个 IDE，可以支持所有的程序语言，这貌似一个不大可能的事情，但是其实没有那么难。有一种叫做“结构化编辑器”的东西，我觉得它可能就是未来编程的终极解决方案。
</p>

<p>
跟普通的 IDE 不同，这种编辑器可以让你 <b>直接编辑程序的 AST 结构</b> ，而不是停留于文本。每一个界面上的“操作”，对应的是一个对 AST 结构的转换，而不是对文本字符的“编辑”。这种 AST 的变化，随之引起屏幕上显示的变化，就像是变化后的 AST 被“pretty print”出来一样。这些编辑器能够直接把程序语言保存为结构化的数据（比如 S表达式，XML 或者 JSON），到时候直接通过对 S表达式，XML 或者 JSON 的简单的“解码”，而不需要针对不同的程序语言进行不同的 parse。这样的编辑器，可以很容易的扩展到任何语言，并且提供很多人都想象不到的强大功能。这对于编程工具来说将是一个革命性的变化。
</p>
</div>
</div>

<div id="outline-container-org497c9e8" class="outline-2">
<h2 id="org497c9e8">程序语言不是工具</h2>
<div class="outline-text-2" id="text-org497c9e8">
<p>
在谈论到程序语言的好坏的时候，总是有人说：“程序语言只是一种工具。只要你的算法好，不管用什么语言都能写出一样好的程序。”可是现在我却发现，这是一个根本错误的说法。
</p>

<p>
Stroustrup 说：
</p>

<blockquote>
<p>
我觉得我们应该看构造出来的应用程序的优雅程度，而不是语言自身的优雅程度。就像你不能把木工的一套复杂的工具（很多是危险的工具）叫做“优雅”一样。但是我的餐桌和椅子却很优雅，很美。
</p>
</blockquote>

<p>
我这篇文章想说的最关键的部分，其实是他所支持的“语言工具论”的错误。
</p>

<p>
……
</p>

<essay>
事实证明，他的这个证明挺无聊的……
</essay>
</div>
</div>

<div id="outline-container-org3fae475" class="outline-2">
<h2 id="org3fae475">ydiff - 结构化的程序比较</h2>
<div class="outline-text-2" id="text-org3fae475">
<p>
ydiff 是我的一个开源项目，用以探索一种全新的程序比较以及版本控制系统。
</p>

<p>
ydiff 跟 diff 是有本质区别的。它们的区别在于，diff 只是对程序进行基于“文本”的对比，它根本不对程序进行 parse。而 ydiff 含有完整的针对程序语言的 parser，在得到了 AST 之后，才对 AST 进行“结构化的比较”。
</p>

<p>
这种结构化的程序比较，不但可以避免文件里的“空白字符”引起的肤浅区别，而且可以根据程序的结构，进行更加有意义的对比。比如，ydiff 不会认为字符串 "1000" 和数字 1000 的区别只是多了一对引号。ydiff 在比较函数的时候，首先寻找名字相同的函数，而不只是对相同位置的函数进行无谓的对比。
</p>

<p>
ydiff 含有 C++, JavaScript 和 Lisp 的 parser。这些 parser，包括用于支持这些 parser 的库代码，都是我自己完成的。ydiff 不含有任何第三方代码。ydiff 的 parser 技术不依赖于任何第三方工具（比如 ANTLR 或者 YACC）。
</p>

<p>
ydiff 里面含有一些比较独特的技术。
</p>

<p>
<span class="underline">#. 强大而简单的 parser combinator library</span>
</p>

<p>
一般编译器的 parser 都使用像 YACC 和 ANTLR 一样的 parser generator。这种方法虽然可行，但是它有一个很大的问题，就是你需要使用另外一种语言和另外一个工具，这样就多了一层“语义”。当你的 parser 出了问题的时候，你不能使用已有的编程工具进行调试，而只能依靠这种 parser 工具所提供的信息。这就是为什么人们都觉得 parser 很难写。
</p>

<p>
由于这个原因，很多人的 parser 都是自己手写的。可是手写 parser 相当的费事，而且不模块化。所以函数式语言的社区就出现了 Parsec 这样的“parser combinator library”。它的原理是，每一个 parser 都是一个函数，它接受一个字符串，输出一种特定的 AST 结构。比如你可以写出一个很简单的 parser，它只能从字符串里提取一个变量，或者一个数字。由于函数式语言可以把函数作为数据，这种小的 parser 可以被一些叫做 parser combinator 的“高阶函数”作为输入，然后把它们“组合”在一起，形成更大的 parser。当所有这些 parser 组合在一起，它们就可以拥有分析整个程序文本的威力，就像“组合金刚大力神”一样。
</p>

<p>
我的 parser 库就是受到了 Parsec 的启发。然而我的库在某种程度上比 parsec 还好用。它不但更加简单灵活，而且能够检测并且报告“左递归”的位置。这是 Parsec 没有的功能。另外，我的 parser 库里面含有很方便的宏，使得写 parser 就像写 BNF 范式一样简单，但却又不需要使用像 YACC 一样的麻烦的工具。
</p>
</div>
</div>

<div id="outline-container-org8bee885" class="outline-2">
<h2 id="org8bee885">原因与证明</h2>
<div class="outline-text-2" id="text-org8bee885">
<p>
大部分的教育过分的重视了“证明”，却忽略了比证明更重要的东西 - “原因”。
</p>

<p>
原因往往比证明来得更加简单，更加深刻，但却更难发现。对于一个事实往往有多种多样的证明，然而导致这个事实的原因却往往只有一个。如果你只知道证明却不知道原因，那你往往就被囚禁于别人制造的理论里面，无法自拔。你能证明一个事物具有某种特性，然而你却没有能力改变它。你无法对它加入新的，好的特性，也无法去掉一个不好的特性。你也无法发明新的理论。有能力发明新的事物和理论的人，他们往往不仅知道“证明”，而且知道“原因”。
</p>

<p>
古人说的“知其然”与“知其所以然”的区别，也就是同样的道理吧。
</p>
</div>
</div>

<div id="outline-container-org4fa9111" class="outline-2">
<h2 id="org4fa9111">我离开了 Coverity</h2>
<div class="outline-text-2" id="text-org4fa9111">
<p>
……
</p>
</div>
</div>

<div id="outline-container-org052ae27" class="outline-2">
<h2 id="org052ae27">PyDiff - Python 结构化程序比较工具</h2>
<div class="outline-text-2" id="text-org052ae27">
<p>
语言的设计不只要有逻辑的严谨和效率，而且需要有“易用性”（usability）。
</p>
</div>
</div>

<div id="outline-container-orgf45dfe1" class="outline-2">
<h2 id="orgf45dfe1">丘奇和图灵</h2>
<div class="outline-text-2" id="text-orgf45dfe1">
<essay>
对立、统一！
</essay>

<p>
丘奇代表了“逻辑”和“语言”，而图灵代表着“物理”和“机器”。
</p>

<p>
虽然现在图灵更加有名，然而在现实的程序设计中，却是丘奇的理论在起着绝大部分的作用。据我的经验，丘奇的理论让很多事情变得简单，而图灵的机器却过度的复杂。丘奇所发明的 lambda calculus 以及后续的工作，是几乎一切程序语言的理论基础。而根据老一辈的计算机工程师们的描述，最早的计算机构架也没有受到图灵的启发，那是一些电机工程师完全独立的工作。
</p>

<p>
图灵机永远的停留在了理论的领域，绝大多数被用在“计算理论”（Theory of Computation）中。计算理论其实包括两个主要概念：“可计算性理论”（computability）和“复杂度理论”（complexity）。这两个概念在通常的计算理论书籍（比如 Sipser的经典教材）里，都是用图灵机来叙述的。
</p>

<p>
其实几乎所有计算理论的原理，都可以用 lambda calculus ，或者程序语言和解释器的原理来描述。所谓“通用图灵机”（Universal Turing Machine），其实就是一个可以解释自己的解释器，叫做“元解释器”（meta-circular interpreter）。然而我的“元解释器”却是基于 lambda calculus 的，所以我后来发现了一种方法，可以完全的用 lambda calculus 来解释计算理论里面几乎所有的定理。
</p>

<essay>
殊途同归？
</essay>

<p>
……
</p>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="date">Date: 2021-02-05 Fri 16:26</p>
<p class="author">Author: Jack Liu</p>
<p class="date">Created: 2021-02-07 Sun 17:00</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
