<!DOCTYPE html>
<html lang="zh">
<head>
<!-- 2021-02-04 Thu 17:56 -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>当然我在扯淡（二）</title>
<meta name="generator" content="Org mode">
<meta name="author" content="Jack Liu">
<link rel="shortcut icon" href="/images/rose-red.png" type="image/x-icon" />
<link rel="stylesheet" type="text/css" href="/dist/style.css" />
<script src="/dist/main.js" defer></script>
</head>
<body>
<div id="content">
<h1 class="title">当然我在扯淡（二）</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orga3132a1">程序语言的常见设计错误(1) - 片面追求短小</a>
<ul>
<li><a href="#org683cb51">自增减操作</a></li>
<li><a href="#org99b87e4">赋值语句返回值</a></li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-orga3132a1" class="outline-2">
<h2 id="orga3132a1">程序语言的常见设计错误(1) - 片面追求短小</h2>
<div class="outline-text-2" id="text-orga3132a1">
<p>
我经常以自己写“非常短小”的代码为豪。
</p>

<p>
我的程序的“短小”是建立在语义明确，概念清晰的基础上的。在此基础上，我力求去掉冗余的，绕弯子的，混淆的代码，让程序更加直接，更加高效的表达我心中设想的“模型”。这是一种在概念级别的优化，而程序的短小精悍只是它的一种“表象”。就像是整理一团电线，并不是把它们揉成一团然后塞进一个盒子里就好。这样的做法只会给你以后的工作带来更大的麻烦，而且还有安全隐患。
</p>

<p>
所以我的这种短小往往是语义和逻辑层面的，而不是在语法上死抠几行代码。我绝不会为了程序显得短小而让它变得难以理解或者容易出错。相反，很多其他人所追求的短小，却是盲目的而没有原则的。在很多时候这些小伎俩都只是在语法层面上，比如想办法把两行代码“搓”成一行。可以说，这种“片面追求短小”的错误倾向，造就了一批语言设计上的错误，以及一批“擅长于”使用这些错误的程序员。
</p>

<p>
现在我举几个简单的“片面追求短小”的语言设计。
</p>
</div>

<div id="outline-container-org683cb51" class="outline-3">
<h3 id="org683cb51">自增减操作</h3>
<div class="outline-text-3" id="text-org683cb51">
<p>
很多语言里都有 i++ 和 ++i 这两个“自增”操作和 i&#x2013; 和 &#x2013;i 这两个“自减”操作（下文合称“自增减操作”。很多人喜欢在代码里使用自增减操作，因为这样可以“节省一行代码”。殊不知，节省掉的那区区几行代码比起由此带来的混淆和错误，其实是九牛之一毛。）
</p>

<p>
从理论上讲，自增减操作本身就是错误的设计。因为它们把对变量的“读”和“写”两种根本不同的操作，毫无原则的合并在一起。这种对读写操作的混淆不清，带来了非常难以发现的错误。相反，一种等价的，“笨”一点的写法， <code>i=1+1</code> ，不但容易理解，而且在逻辑上更加清晰。
</p>

<p>
有些人很在乎 <code>i++</code> 与 <code>++i</code> 的区别，去追究 <code>(i++) + (++i)</code> 这类表达式的含义，追究 <code>i++</code> 与 <code>++i</code> 谁的效率更高。这些其实都是徒劳的。比如， <code>i++</code> 与 <code>++i</code> 的效率差别，其实来自于早期 C 编译器的愚蠢。因为 <code>i++</code> 需要在增加这后返回 <code>i</code> 原来的值，所以它其实被编译为：
</p>

<pre class="example">
(tmp = i, i = i + 1, tmp)
</pre>

<p>
但是在
</p>

<pre class="example">
for (int i = 0; i &lt; max; i++)
</pre>

<p>
这样的语句中，其实你并不需要在 <code>i++</code> 之后得到它自增前的值。
</p>

<essay>
原来，是这个意思，原来是这样……
</essay>

<p>
所以有人说，在这里应该用 <code>++i</code> 而不是 <code>i++</code> ，否则你就会浪费一次对中间变量 <code>tmp</code> 的赋值。而其实呢，一个良好设计的编译器应该在两种情况下都生成相同的代码。这是因为在 <code>i++</code> 的情况，代码其实先被转化为：
</p>

<pre class="example">
for (int i = 0; i &lt; max; (tmp = i, i = i + 1, tmp))
</pre>

<p>
由于 <code>tmp</code> 这个临时变量从来没用过，所以它会被编译器的 “dead code elimination” 消去。所以编译器最后实际上得到了：
</p>

<pre class="example">
for (int i = 0; i &lt; max; i = i + 1)
</pre>

<p>
所以，“精通”这些细微的问题，并不能让你成为一个好和程序员。很多人所认为的高明的技巧，经常都是因为早期系统设计的缺陷所致。一旦这些系统被改进，这些技巧没什么用处了。
</p>

<p>
真正正确的做法其实是：完全不使用自增操作，因为它们本来就是错误的设计。
</p>
</div>
</div>

<div id="outline-container-org99b87e4" class="outline-3">
<h3 id="org99b87e4">赋值语句返回值</h3>
<div class="outline-text-3" id="text-org99b87e4">
<p>
在几乎所有像 C，C++，Java 的语言里， <b>赋值语句都可以被作为值</b> 。之所以设计成这样，是因为你就可以写这样的代码：
</p>

<pre class="example">
if (y = 0) { ... }
</pre>

<p>
而不是
</p>

<pre class="example">
y = 0;
if (y) { ... }
</pre>

<p>
程序好像缩短了一行，然而，这种写法经常引起一种常见的错误，那就是为了写 <code>if (y == 0) { ... }</code> 而把 <code>==</code> 比较操作符少打了一个 <code>=</code> ，变成了 <code>if (y = 0) { ... }</code> 。很多人犯这个错误，是因为数学里的 <code>=</code> 就是比较两个值是否相等的意思。
</p>

<p>
正确的做法是什么呢？在一个类型完备的语言里面，像 <code>y=0</code> 这样的赋值语句，其实是不应该可以返回一个值的，所以它不允许你写：
</p>

<pre class="example">
x = y = 0
</pre>

<p>
或者
</p>

<pre class="example">
if ( y = 0) { ... }
</pre>

<p>
这样的代码。
</p>

<p>
<code>x = y = 0</code> 的工作原理其实是这样：经过 parser 它其实变成了 <code>x = (y = 0)</code> （因为 <code>=</code> 操作符是“右结合”的）。 <code>x = (y = 0)</code> 这个表达式也就是说 <code>x</code> 被赋值为 <code>(y = 0)</code> 的值。注意，我说的是 <code>(y = 0)</code> 这整个表达式的值，而不是 <code>y</code> 的值。所以这里的 <code>(y = 0)</code> 既有副作用又是值，它返回 <code>y</code> 的“新值”。
</p>

<p>
正确的做法其实是： <code>y = 0</code> 不应该具有一个值。它的作用应该是“赋值”这种“动作”，而不应该具有任何“值”。即使牵强一点硬说它有值，它的值也应该是 <code>void</code> 。这样一来 <code>x = y = 0</code> 和 <code>if (y = 0)</code> 就会因为“类型不匹配”而被编译器拒绝接受，从而避免了可能出现的错误。
</p>

<essay>
从源头解决问题的出现，而不只为了解决出现的问题。
</essay>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="date">Date: 2021-02-04 Thu 16:54</p>
<p class="author">Author: Jack Liu</p>
<p class="date">Created: 2021-02-04 Thu 17:56</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
